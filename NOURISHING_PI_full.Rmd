---
title: "NOURISHING_PI_Full"
author: "Jonas Rekdal Mathisen"
date: "03/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Introduction
This document outlines the NOURISHING policy index methodology using.COINr.

#Data
We benchmarked five CO-CREATE countries: Norway, Poland, Netherlands, United Kingdom and Portugal. The framework is based on the NOURISHING framework:

![Alt text](C:\Users\JRMA\OneDrive - Folkehelseinstituttet\Dokumenter\CO-CREATE\graphs\PPA-Nourishing-WEB.jpg.webp)

Data manipulation and visualisation is used with the aid of the following packages available from CRAN: 

```{r Packages}
#libraries:
pacman::p_load(COINr, ggbiplot, countrycode, reactable, tidyverse, RColorBrewer)
```

#Initialisation
https://bluefoxr.github.io/COINrDoc/coins-the-currency-of-coinr.html


##Input data
```{r load, warning=FALSE}

library(readxl, suppressMessages(T))

#Import the benchmarking results to R
Benchmark_raw <- read_excel("benchmark1301.xlsx", 
    sheet = "All_countries_format")

# #Add PD code
# Benchmark_raw$PD_code <- case_when(
#   Benchmark_raw$`Policy dimension` == "Food environment" ~"FoodEnv",
#   Benchmark_raw$`Policy dimension` == "Food system" ~ "FoodSyst",
#   Benchmark_raw$`Policy dimension` == "Behaviour change communication" ~ "BehCha"
# )

numericals <- c("NO_final_numeric", "PL_final_numeric", "UK_final_numeric", "PT_final_numeric", "NL_final_numeric")


Benchmark_raw <- Benchmark_raw %>% 
  mutate(
    across(where(is.numeric), ~replace_na(.x, 0))
  )

Benchmark_raw <- Benchmark_raw %>% 
  mutate(
    across(where(is.numeric), ~ replace(.x, 99, 0))
  )


Benchmark_raw <- Benchmark_raw %>% 
  filter(is.na(Indicator_type) | Indicator_type != "M&E" & Indicator_type != "Implementation")

#Benchmark_reduced
Benchmark_raw %>% head(5) %>% reactable(compact=T)

```

```{r}
#Include only if replace zereos
countries_f <- c("NO_final_numeric", "PL_final_numeric", "UK_final_numeric", "PT_final_numeric", "NL_final_numeric")

    #Bruk bare om alt er null, ikke NA
# Benchmark_raw <- Benchmark_raw %>% mutate(across(.cols = all_of(countries_f), ~case_when(is.na(.) ~ NA, TRUE ~ .)))
                                                
```

Note, I create two datasets. A full version from the original benchmark and a reduced version. The latter excludes M&E and implementation questions.

This amounts to `r nrow(Benchmark_raw)` for the raw version, while the reduced versions has `r nrow(Benchmark_reduced)`. Difference equals to `r (nrow(Benchmark_raw)-nrow(Benchmark_reduced))`

##Transform data to COINr
###Indicator Data (IndData)
```{r}
#Select countries benchmarked and indicator ID only
IndData_NPI_F <- Benchmark_raw %>% select(c("UniqueID", "NO_final_numeric", "PL_final_numeric", "UK_final_numeric", "PT_final_numeric", "NL_final_numeric"))

#Assign proper names
colnames(IndData_NPI_F) <- c("UniqueID", "Norway", "Poland", "United Kingdom", "Portugal", "Netherlands")

#List of indicators
Indicators <- c(t(IndData_NPI_F$UniqueID))

#Transpose the table, add column names
IndData_NPI_F <- data.frame(t(IndData_NPI_F[-1]))
colnames(IndData_NPI_F) <- Indicators

#Go to COIN

#Fix the index
IndData_NPI_F$UnitName <- rownames(IndData_NPI_F)
row.names(IndData_NPI_F) <- NULL


#Make unit codes
IndData_NPI_F <- IndData_NPI_F %>% mutate(UnitCode = countrycode(sourcevar = UnitName, origin="country.name", destination="iso3c"))

isCoCREATE <- c("NOR", "NLD", "PRT", "POL", "GBR")

#Continue adding groups for countries 
IndData_NPI_F <- IndData_NPI_F %>% mutate(
  Group_Continent = countrycode(sourcevar = UnitName, origin="country.name", destination="continent"), 
  Group_EU = countrycode(sourcevar = UnitName, origin="country.name", destination="eu28"),
  Group_Region = countrycode(sourcevar = UnitName, origin="country.name", destination="un.regionsub.name"), 
  Group_COCREATE = case_when(UnitCode %in% unlist(isCoCREATE) ~ TRUE, TRUE ~ FALSE))

#Potential groups: GDP, inequality etc, obesity prevalence etc.

IndData_NPI_F <- IndData_NPI_F %>% mutate_if(is_double,as.integer)

```

###Indicator metadata (IndMeta)

```{r}
AggHier <- Benchmark_raw %>% select("UniqueID", "Benchmark ID", "Policy letter") %>% distinct()

#OLD: AggHier <- Benchmark_raw %>% select("UniqueID", "Benchmark ID", "Policy letter", "PD_code") %>% distinct()


colnames(AggHier) <- c("UniqueID", "Agg_SubPA", "Agg_PA")

#OLD: colnames(AggHier) <- c("UniqueID", "Agg_SubPA", "Agg_PA", "Agg_PolDim")

#Select countries benchmarked and indicator ID only
IndMeta_NPI_f <- Benchmark_raw %>% select(matches("final_numeric$|UniqueID$|Indicator name$|Max_scale$"))
  #ADD UNITS OF THE INDICATOR (INDUNIT) TO ORIGINAL EXCEL

#Assign proper names
colnames(IndMeta_NPI_f) <- c("IndCode", "IndName", "Norway", "Poland", "United Kingdom", "Portugal", "Netherlands", "Target")

IndMeta_NPI_f$Direction <- 1 #All indicators got positive direction
IndMeta_NPI_f$IndWeight <- 1 #All indicators carry the same weight

IndMeta_NPI_f <- left_join(IndMeta_NPI_f,AggHier, by=c("IndCode"="UniqueID"))

IndMeta_NPI_f$Agg_Index <- "NOURISHING"
```


### Aggregation metadata (AggMeta)

```{r}
#AggMeta <- Benchmark_raw %>% select("Policy dimension", "Policy area", "Policy letter", "Sub-policy area", "Benchmark ID") %>%

#SubPA = 1

SubPas <- Benchmark_raw %>% select("Sub-policy area", "Benchmark ID") %>% distinct()

colnames(SubPas) <- c("Name", "Code")

SubPas$AgLevel = 2

#PA = 2
PAreas <- Benchmark_raw %>% select("Policy area", "Policy letter") %>% distinct()

colnames(PAreas) <- c("Name", "Code")

PAreas$AgLevel = 3
# 
# #PD = 3
# PD <- Benchmark_raw %>% select("Policy dimension", "PD_code") %>% distinct()
# 
# colnames(PD) <- c("Name", "Code")
# 
# PD$AgLevel = 4

#Merge the three aggregation levels
AggMeta_NPI_f <- do.call("rbind", list(SubPas, PAreas))

#OLD: AggMeta_NPI_f <- do.call("rbind", list(SubPas, PAreas, PD))


AggMeta_NPI_f$Weight = 1 

#INDEX = 4
AggMeta_NPI_f <- AggMeta_NPI_f %>% add_row(Name="NOURISHING Policy Index", Code="NOURISHING", AgLevel=4, Weight=1)

#OLD: AggMeta_NPI_f <- AggMeta_NPI_f %>% add_row(Name="NOURISHING Policy Index", Code="NOURISHING", AgLevel=5, Weight=1)

```

###Assemble the data to COINr

```{r}
NPI_f <- assemble(IndData_NPI_F, IndMeta_NPI_f, AggMeta_NPI_f)
```

# Initial visualisation and analysis
## Structure
The sunburst plot shows the hierarchical structure and effective weights for the simplified NOURISHING index. Effective weights imply their relative contribution to the aggregated level, even with equal weighting applied. 

```{r Structure}
framework <- plotframework(NPI_f)
framework

#Kunne man hatt e.g. et LAND i midten? De som er N/A kan gråes ut. E.g H7 -> Nei = Grå. Om alle i FoodSyst=0, blir alt der grått etc.
```

# Missing analysis 
In total, there are `r nrow(Benchmark_raw)` indicators. 

Reading the PrcDataAll (where there is data), for Norway it accounts 46.8% of cases. That means half of the data is empty... The worst is for Poland with 36% filled values.

Key takeaway for this chapter: huge amount of missing data.

The PrcNonZero indicate another interesting finding. A high number of zeroes would mean low score in the selected policy and may serve as a first indication on the strength of the implemented polices overall. Norway has a high NonZero rate (66%), while the Netherlands has 54%. 

```{r}
NPI_f <- checkData(NPI_f, dset="Raw")

NPI_f$Analysis$Raw$MissDatSummary %>% roundDF(1) %>% reactable(compact=T)
```
##Overall NOURISHING
```{r}
#Colour scheme
library("reactablefmtr")

temppal <- c("#c62c34", "#d65440","#d88359","#ffffff", "#76b8de","#a0bfd9", "#36a1d6")

```


This table identifies how many percent of the data is filled with a number per aggregation level. This means THE HIGHER THE NUMBER, the MORE is filled in the dataset.

"NOURISHING", (previously, PrcDataAll), is the same as earlier. The second highest aggregation level is Behavioural change communication, Food environment and Food systems. Higher number is better (% filled) 
```{r}
# agg34 <-  NPI_f$Analysis$Raw$MissDatByGroup %>% select("NOURISHING", "BehCha", "FoodEnv", "FoodSyst") %>% roundDF(1)
# 
# reactable(
#   agg34,
#   defaultColDef = colDef(
#     style = color_scales(agg34, span =T, colors = temppal),
#     minWidth = 50
#     )
# )

```

## Sub-policy area groups
The same grouping can be done by policy area:

Number of indicators filled / total indicators possible.

```{r}
supb_table <- NPI_f$Analysis$Raw$MissDatByGroup %>% select(UnitCode, N, O, U, R, I, S, H, "I(2)", "N(2)", G) %>% roundDF(1)

reactable(
  supb_table,
  defaultColDef = colDef(
    style = color_scales(supb_table, span = TRUE, colors = temppal),
    minWidth = 50
    )
)

```
## Benchmarks 

No data should be 0: every benchmark should have been marked YES or NO. 
Action point: go through and review data. Multiple missing that shoudn't.
```{r}

bench <- NPI_f$Analysis$Raw$MissDatByGroup %>% select(-N, -O, -U, -R, -I, -S, -H, -"I(2)", -"N(2)", -G, -"NOURISHING") %>% roundDF(1)

#OLD: bench <- NPI_f$Analysis$Raw$MissDatByGroup %>% select(-N, -O, -U, -R, -I, -S, -H, -"I(2)", -"N(2)", -G, -"NOURISHING", -"BehCha", -"FoodEnv", -"FoodSyst") %>% roundDF(1)


reactable(
  bench,
  defaultColDef = colDef(
    style = color_scales(bench, span = TRUE, colors = temppal),
    minWidth = 50
    )
)


write.csv(bench,file="benchies.csv",row.names=T)
```
# Implementation markers
```{r}
#Retrieve the 0.0 indicators only.
BenchmarkYes <- NPI_f$Data$Raw %>% column_to_rownames("UnitCode") %>% select(contains(".0.0"))

```


This table should be empty:
```{r}
#Missing benchmarks values (not OK)
missing_bench <- t(BenchmarkYes)
missing_bench <- missing_bench[rowSums(is.na(missing_bench)) > 0,]

missing_bench %>% reactable()

```


```{, include=F}
#finn kode fra simplified index og hent opp aggresjonsnivåene.
BenchmarkYes %>% pheatmap::pheatmap(color=colorRampPalette(c("red", "forestgreen"))(50), legend = F, cluster_rows = F, cluster_cols = F, main = "Policy action benchmarked")

BenchmarkYes
```

<!-- Won't work if filtered reduced. -->
<!-- ```{r, include=F} -->
<!-- BM_col <- BenchmarkYes %>% t() %>% as.data.frame() %>% rownames_to_column("UniqueID") -->

<!-- Keychain_0s <- AggHier %>% filter(grepl(".0.0", UniqueID)) -->

<!-- BM_col <- left_join(BM_col, Keychain_0s) %>% as.data.frame() -->

<!-- #Simplify heatmap by changing rownames -->
<!-- subpba_BM <- column_to_rownames(BM_col, "Agg_SubPA") -->

<!-- agg <- subpba_BM %>% select("Agg_PA") %>% as.data.frame() -->

<!-- subpba_BM <- subpba_BM %>% select("NOR", "POL", "GBR", "PRT", "NLD") %>% t() %>% as.data.frame() -->

<!-- ``` -->



<!-- ```{r} -->
<!-- subpba_BM %>% pheatmap::pheatmap(color=colorRampPalette(c("red", "forestgreen"))(50), legend = F, cluster_rows = F, cluster_cols = F, main = "Policy action benchmarked", annotation_col = agg) -->
<!-- ``` -->


<!-- #Cross check with WCRF online database -->
<!-- ```{r, eval=F, include=F} -->
<!-- simplified_index_cc <- NumericalsSuBPOnly %>% filter(rownames(NumericalsSuBPOnly) %in% c("Norway", "Poland", "Netherlands", "Portugal", "UK")) -->

<!-- rownames(simplified_index_cc) <- c("GBR", "NOR", "NLD", "POL", "PRT") -->

<!-- compare <- full_join(subpba_BM, simplified_index_cc) %>% t() -->

<!-- compare -->

<!-- colnames(compare) <- c("GBR", "NOR", "NLD", "POL", "PRT", "sGBR", "sNOR", "sNLD", "sPOL", "sPRT") -->

<!-- compare <- compare %>% as.data.frame() -->

<!-- write.csv(compare,file="compare.csv",row.names=T) -->

<!-- compare -->

<!-- compare %>% select("GBR", "sGBR") %>% reactable(searchable = T) -->

<!-- #Simplified structure -->
<!-- website <- simplified_index_cc %>% t() %>% row.names() %>% sort() -->

<!-- #Ensure consistency in () -->



<!-- #Benchmark structure -->
<!-- benche <- subpba_BM %>% t() %>% row.names() %>% sort() -->

<!-- benche -->
<!-- benche <- benche %>% str_replace("\\(", ".") -->

<!-- benche <- benche %>% str_replace("\\)", ".") -->

<!-- inboth <- website[website %in% benche] # inboth -->

<!-- website_only <- website[!website %in% benche] # only 1st -->

<!-- benchmarkTool_only <- benche[!benche %in% website] # only 2nd. Dette bør være lett å fikse. Replace (/) med . -->

<!-- #Ioana's export -->
<!-- write.csv(benchmarkTool_only,file="benchmarkTool_only.csv",row.names=F) -->


<!-- ``` -->

# COINr continuation



## Normalisation
```{r}
NPI_f <- normalise(NPI_f, dset="")


NPI_f <- normalise(NPI_f, dset="Raw", ntype="prank")

NPI_f$Data$Normalised %>% reactable(compact=T)

```

```{r, eval=F, include=F}
#I added the following function to the R tool 
trace(normalise, edit = T)


    else if (ntype == "percentOftarg") {
      if (is.data.frame(df)) {
        dfn <- purrr::modify2(df, COIN$Input$IndMeta$Target, 
          ~{
            (.x/.y)
          })
        dfn[dfn > 1] <- 1
      }
      else {
        dfn <- (df/COIN$Input$IndMeta$Target[ii])
        dfn[dfn > 1] <- 1
      }
    }
```


<!-- Alternativ normalisering: prosent -->
```{r}
NPI_f <- normalise(NPI_f, dset="Raw", ntype="percentOftarg")
```


```{r}
NPI_f$Data$Normalised

```

# Aggregation

```{r}
#Simple averages of percent
NPI_f <- aggregate(NPI_f, dset="Normalised", agtype_bylevel = c("arith_mean", "harm_mean", "harm_mean"), avail_limit = 0.8)
```


```{r}
#Results
getResults(NPI_f, tab_type = "Aggregates")
write.csv(perc, file="PercCalcMean.csv", row.names=T)
#Note how this aggregation technique uses averages and not the full sum!! 
```

Example of calculation of N:
```{r}

N_calc1 <- mean(0.61, 0.92, 0.33, 0.5, 0.93, 0,52, NA)
```
```{r}
iplotRadar(NPI_f, dset = "Aggregated", usel = isCoCREATE, aglev = 2, addstat = "median")

```
```


## RAW Aggregation
This is the raw aggregation levels. Note how low the scores are, even without normalising.
```{r}
#Two options: copeland OR arith_mean.
SumFunction <- function(x,w) (sum(x, na.rm = T)*1)

NPI_f <- aggregate(NPI_f, dset="Raw", agtype="custom", agfunc = SumFunction) 

#TryNewDataFrame
## Identifisere hva de deler på
## Lage ny dataframe med riktig antall columns hvor max score finnes.


#NPI_f$Input$IndMeta$Target



getResults(NPI_f, tab_type = "Aggregates") %>% reactable()

write.csv(test, file="TargetScores.csv", row.names=T)

write
```


```{r}
iplotRadar(NPI_f, dset = "Aggregated", usel = isCoCREATE, aglev = 3, addstat = "median")
```

```{r}
getResults(NPI_f, tab_type = "Aggregates", use = "ranks") %>% reactable()
```


